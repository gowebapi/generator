// Code generated by webidl-bind. DO NOT EDIT.

// +build !js

package dict

import js "github.com/gowebapi/webapi/core/failjs"

// using following types:

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// dictionary: Test1
type Test1 struct {
	A int
	B js.Value
	C []int
	D []js.Value
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *Test1) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.A
	out.Set("a", value0)
	value1 := _this.B
	out.Set("b", value1)
	value2 := js.Global().Get("Array").New(len(_this.C))
	for __idx, __seq_in := range _this.C {
		__seq_out := __seq_in
		value2.SetIndex(__idx, __seq_out)
	}
	out.Set("c", value2)
	value3 := js.Global().Get("Array").New(len(_this.D))
	for __idx, __seq_in := range _this.D {
		__seq_out := __seq_in
		value3.SetIndex(__idx, __seq_out)
	}
	out.Set("d", value3)
	return out
}

// Test1FromJS is allocating a new
// Test1 object and copy all values from
// input javascript object
func Test1FromJS(value js.Wrapper) *Test1 {
	input := value.JSValue()
	var out Test1
	var (
		value0 int        // javascript: long {a A a}
		value1 js.Value   // javascript: any {b B b}
		value2 []int      // javascript: sequence<long> {c C c}
		value3 []js.Value // javascript: sequence<any> {d D d}
	)
	value0 = (input.Get("a")).Int()
	out.A = value0
	value1 = input.Get("b")
	out.B = value1
	__length2 := input.Get("c").Length()
	__array2 := make([]int, __length2, __length2)
	for __idx := 0; __idx < __length2; __idx++ {
		var __seq_out int
		__seq_in := input.Get("c").Index(__idx)
		__seq_out = (__seq_in).Int()
		__array2[__idx] = __seq_out
	}
	value2 = __array2
	out.C = value2
	__length3 := input.Get("d").Length()
	__array3 := make([]js.Value, __length3, __length3)
	for __idx := 0; __idx < __length3; __idx++ {
		var __seq_out js.Value
		__seq_in := input.Get("d").Index(__idx)
		__seq_out = __seq_in
		__array3[__idx] = __seq_out
	}
	value3 = __array3
	out.D = value3
	return &out
}

// interface: Foo
type Foo struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Foo) JSValue() js.Value {
	return _this.Value_JS
}

// FooFromJS is casting a js.Wrapper into Foo.
func FooFromJS(value js.Wrapper) *Foo {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &Foo{}
	ret.Value_JS = input
	return ret
}

// Test1 returning attribute 'test1' with
// type Test1 (idl: Test1).
func (_this *Foo) Test1() *Test1 {
	var ret *Test1
	value := _this.Value_JS.Get("test1")
	ret = Test1FromJS(value)
	return ret
}

// SetTest1 setting attribute 'test1' with
// type Test1 (idl: Test1).
func (_this *Foo) SetTest1(value *Test1) {
	input := value.JSValue()
	_this.Value_JS.Set("test1", input)
}
